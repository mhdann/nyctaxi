y1 = points1[,'y']
y2 = points2[,'y']
X <- c()
Y <- c()
start <- y1[1] > y2[1]
for(i in 2:length(x)){
y1Greater = y1[i] > y2[i]
if(xor(start, y1Greater)){
L1 = pointsToLine(P1 = c(x[i-1], y1[i-1]), P2 = c(x[i], y1[i]))
L2 = pointsToLine(P1 = c(x[i-1], y2[i-1]), P2 = c(x[i], y2[i]))
P  = lineIntersect(L1, L2)
X  = c(X,P[1])
Y  = c(Y,P[2])
}
start = y1Greater
}
return(data.frame(x = X, y = Y))
}
functionGenerator <- function(points){
f <- function(x){
ind <- which(points[,'x'] %in% x)
if(length(ind)!=0){
return(points[ind,'y'])
}
greater = x > points[,'x']
start   = sum(greater)
end     = start + 1
return((points[start,'y'] + points[end,'y'])/2)
}
return(f)
}
truncPoints <- function(points, crossPoints){
a <- crossPoints[1,'x']
b <- crossPoints[2,'x']
index <- (points[,'x'] > a) & (points[,'x'] < b)
rbind(rbind(crossPoints[1,], points[index, ]), crossPoints[2,])
}
# End library
L <- list()
for(plant in DATA[HUC2==18,unique(plant_code)]){
R <-list()
R$plant_code <- plant
f <- as.matrix(monthly[plant_code==plant,list(percentGen, percentTotrun)])
if(any(is.na(f))){next}
points1 = seasonToCycle(f[,1])
points2 = seasonToCycle(f[,2])
crossPoints <- crossover(points1, points2)
R$crossPoints <- crossPoints
R$generation  <- points1
R$totrun      <- points2
if(dim(crossPoints)[1]==2){
# truncate points1 and points2 to the crossover points
points1_trunc <- truncPoints(points1, crossPoints)
points2_trunc <- truncPoints(points2, crossPoints)
A1 = trapz(points1_trunc$x, points1_trunc$y)
A2 = trapz(points2_trunc$x, points2_trunc$y)
R$storage <- abs(A1-A2)
} # bail if multiple points
n <- length(L)+1
L[[n]] <- R
names(L)[n] <- plant
}
L[[40]]
L[[40]]$crossPoints
plot(L[[40]]$totrun)
lines(L[[40]]$totrun)
lines(L[[40]]$generation)
abline(v=L[[40]][,"x"])
abline(v=L[[40]]$crossPoints[,"x"])
plotIt <- function(R){
plot(R$totrun)
lines(R$totrun)
lines(R$generation)
abline(v=R$crossPoints[,"x"])
}
plotIt(L[[40]])
plotIt(L[[39]])
abline(v=R$crossPoints[,"x"], lty=2)
plotIt <- function(R){
plot(R$totrun)
lines(R$totrun)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
plotIt(L[[39]])
plotIt <- function(R){
plot(R$totrun)
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
plotIt(L[[39]])
plot(R$totrun, xlab="Month", ylab="Percent")
plot(R$totrun, xlab="Month", ylab="Percent", main=R$plant)
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
lapply(R)
plotIt(L[[29]])
plotIt(L[[28]])
plotIt(L[[27]])
plotIt(L[[25]])
plotIt(L[[24]])
plotIt(L[[23]])
plotIt(L[[22]])
plotIt(L[[21]])
plot(R$totrun, xlab="Month", ylab="Percent", title=R$plant)
plotIt <- function(R){
plot(R$totrun, xlab="Month", ylab="Percent", main=R$plant)
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
warnings()
21
plotIt(L[[21]])
dt_unit_info[plant_code==240]
dt_unit_info[plant_code==240, plant.dam.name]
plotIt(L[[20]])
dt_unit_info[plant_code==239, plant.dam.name]
dt_unit_info[plant_code==233, plant.dam.name]
dt_unit_info[plant_code==232, plant.dam.name]
plotIt(L[[19]])
plotIt(L[[50]])
plotIt(L[[100]])
plotIt <- function(R){
plot(R$totrun, xlab="Month", ylab="Percent", main=paste(R$plant,": ", round(R$storage)))
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
plotIt(L[[100]])
plotIt <- function(R){
plot(R$totrun, xlab="Month", ylab="Percent", main=paste(R$plant,": ", round(R$storage,3)))
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
plotIt(L[[100]])
ecm.sim <- function(L1.Y, L1.X, X, beta){
# Can handle multi-dimensional X, but not Y
D1.X = X - L1.X
Y = D1.X %*% t(beta$SR) + beta$adj * (L1.Y - L1.X %*% t(beta$LR))
return(Y)
}
LR.beta       = 2
SR.beta       = 1
adj.beta      = 0.5      # Percent falloff back to trend. 1 = complete adj.
per     = 1 - adj  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
LR.Y = LR.beta*X   # Underlying LR trend
per     = 1 - adj.beta  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
LR.Y = LR.beta*X   # Underlying LR trend
shocks = c(1, rep(0,99))
#shocks = rnorm(100, sd=0.2)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ecm.sim <- function(L1.Y, L1.X, X, beta){
# Can handle multi-dimensional X, but not Y
D1.X = X - L1.X
Y = D1.X %*% t(beta$SR) + beta$adj * (L1.Y - L1.X %*% t(beta$LR))
return(Y)
}
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y)
ts.plot(Y,x)
ts.plot(Y,X)
ts.plot(Y,ts(X))
LR.beta       = 2
SR.beta       = 1
adj.beta      = -0.5      # Percent falloff back to trend. 1 = complete adj.
per     = 1 - adj.beta  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
shocks = c(1, rep(0,99))
#shocks = rnorm(100, sd=0.2)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
per     = adj.beta-1  # Persistence of shocks
ts.plot(shocks)
shocks = rnorm(100, sd=0.2)
LR.beta       = 2
SR.beta       = 1
adj.beta      = -0.5      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.2)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
shocks = rnorm(100, sd=1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
ecm.sim <- function(L1.Y, L1.X, X, beta){
# Can handle multi-dimensional X, but not Y
D1.X = X - L1.X
D.Y = D1.X %*% t(beta$SR) + beta$adj * (L1.Y - L1.X %*% t(beta$LR))
return(D.Y)
}
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -0.5      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
ts.plot(Y,ts(X), col=(c(2,1)))
ts.plot(LR.y)
ts.plot(LR.Y)
ts.plot(Y,ts(X), col=(c(2,1)))
ts.plot(shocks)
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
shocks = rnorm(100, sd=0.1)
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -1      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -0.1      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -0.6      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -0.2      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
shocks = rnorm(100, sd=0.1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 2
adj.beta      = -0.2      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 0
SR.beta       = 2
adj.beta      = -0.2      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
LR.beta       = 0
SR.beta       = 2
adj.beta      = 0      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
N             = 100
LR.beta       = 0
SR.beta       = 2
adj.beta      = 0      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,N)*(2*pi)/12)
#shocks = c(1, rep(0,99))
shocks = rnorm(N, sd=0.1)
Y = rep(as.numeric(NA),N)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
".RData"
ls()
pwd()
q()
a
a
library(data.table)
library(ggplot2)
library(lubridate)
urls2015 = c(paste0("https://storage.googleapis.com/tlc-trip-data/2014/yellow_tripdata_2014-0", 1:6,".csv"))
# Yellow cab data, 2014
urls2014 = c(paste0("https://storage.googleapis.com/tlc-trip-data/2014/yellow_tripdata_2014-0", 1:9,".csv"),
"https://storage.googleapis.com/tlc-trip-data/2014/yellow_tripdata_2014-11.csv",
"https://storage.googleapis.com/tlc-trip-data/2014/yellow_tripdata_2014-12.csv")
setwd("D:\\data\\taxi")
files = list.files("nyc_yellow/", full.names = T)
files = list.files("nyc_yellow/", full.names = T)
f2015 <- files[grep("2015", files)]
wunder = fread("./wunder/wunder.csv")
removeVars <- function(dt, vars = c("VendorID", "store_and_fwd_flag", "extra", "mta_tax", "tip_amount", "tolls_amount", "improvement_surcharge")){
# Removes variables not currently under analysis
dt[, (vars) := NULL] # () added so that it gets seen as an expression
print(paste0("Removed: ", paste(vars, collapse=", ")))
}
clean <- function(dt){
# Clean the raw data of unrealistic distances and trip costs per mile
# append "clean" field using side-effects of data.table references
dt[, clean := F]
dt[trip_distance < 100 &
fare_amount/trip_distance < 20 &
fare_amount/trip_distance > 1 &
pickup_longitude < -72 &
pickup_longitude > -75 &
pickup_latitude < 41.5 &
pickup_latitude > 40,
clean := T]
print("Added 'clean' field to indicate valid data")
}
appendDateTime <- function(dt){
# Append POSIX time variables, remove raw
# Side-effects herein, reader beware
dt[,pickup_datetime:= as.POSIXct(tpep_pickup_datetime, format="%Y-%m-%d %H:%M:%S")]
dt[,dropoff_datetime:= as.POSIXct(tpep_dropoff_datetime, format="%Y-%m-%d %H:%M:%S")]
dt[,tpep_pickup_datetime:= NULL]
dt[,tpep_dropoff_datetime:= NULL]
}
appendDate <- function(dt){
# Append Date using POSIX time field
dt[,pickup_date := as.Date(pickup_datetime)]
dt[,dropoff_date := as.Date(dropoff_datetime)]
}
appendMonth <- function(dt){
# Append Date using POSIX time field
dt[,pickup_month := month(pickup_datetime)]
dt[,dropoff_month := month(dropoff_datetime)]
print("Added month")
}
appendDay <- function(dt){
# Append Date using POSIX time field
dt[,pickup_day := mday(pickup_datetime)]
dt[,dropoff_day := mday(dropoff_datetime)]
print("Added day")
}
appendHour <- function(dt){
# Append Date using POSIX time field
dt[,pickup_hour  := hour(pickup_datetime)]
dt[,dropoff_hour := hour(dropoff_datetime)]
print("Added hour")
}
appendMin <- function(dt){
# Append Date using POSIX time field
dt[,pickup_min  := minute(pickup_datetime)]
dt[,dropoff_min := minute(dropoff_datetime)]
print("Added min")
}
cleanAll <- function(dt, ...){
removeVars(dt, ...)
clean(dt)
appendDateTime(dt)
appendDay(dt)
appendHour(dt)
}
# reading
taxis2015 = lapply(f2015, fread)
# Screening
lapply(taxis2015, cleanAll)
# Binding (RAM WARNING > 20 GB!)
t2015 = rbindlist(taxis2015)
rm(taxis2015); gc()
size(t2015)
object.size(t2015)
t2015[clean == T, trip_time := as.numeric(difftime(dropoff_datetime, pickup_datetime, units = "hour"))]
t2015[clean == T, fare_rev_per_hour := fare_amount/trip_time]
t2015[, Weekday := factor(weekdays(pickup_datetime), levels = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"))]
# month
t2015[, Month := month(pickup_datetime)]
library(RSQLite)
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./taxiDB/nyc.db")
con <- dbConnect(drv, dbname = "./nyc_DB/nyc.db")
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./nyc_DB/nyc.db")
setwd("D:/data/taxi/nyctaxi/")
library(RSQLite)
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./nyc_DB/nyc.db")
dbWriteTable(con, "2015", t2015[month==1,])
dbWriteTable(con, "2015", t2015[Month==1,])
dbWriteTable(con, "nyc_yellow", t2015[Month==1,])
dbDisconnect(con)
names(t2015)
t2015[,cleanDupe := clean]
t2015[clean == T & !(trip_time > 1/60 & fare_rev_per_hour < 1000), clean := F]
t2015[,cleanDupe := NULL]
tables()
t2015[Month==1]
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./nyc_DB/nyc.db")
dbWriteTable(con, "nyc_yellow", t2015[Month==1,])
dbDisconnect(con)
con <- dbConnect(drv, dbname = "./nyc_DB/nyc.db")
test = data.table(dbReadTable(con, "nyc_yellow"))
dim(test)
dim(t2015[Month==1])
identical(test, t2015[Month==1])
test
dbDisconnect(con)
for(m in 2:6){
con <- dbConnect(drv, dbname = "./nyc_DB/nyc.db")
dbWriteTable(con, "nyc_yellow", t2015[Month==m,],append = T)
dbDisconnect(con)
}
rm(t2015)
gc()
