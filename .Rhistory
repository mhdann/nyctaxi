results <- data.table(results)
setkey(results,plant_code)
results <- merge(results, dt_unit_info[,list(plant_code, HUC2, nStorage, drain)], by=c("plant_code"))
setkey(results,HUC2)
return(results)
}
res1 <- returnResults(R)
res2 <- returnResults(Re)
res2
res2$R2
mean(res2$R2)
Re
coef   <- do.call(rbind,lapply(Re, function(x){x$coefficients}))
coef
dim(coef)
dimnames(coef)
Re[[1]]
Re[[2]
]
Re[[1]]@coefficients
Re[[1]]$coefficients
S <- lapply(Re, summary)
Rsq    <- do.call(rbind,lapply(S, function(x){x$r.squared}))
Rsq
Re[[1]]$coefficients
dim(Re[[1]]$coefficients)
length(Re[[1]]$coefficients)
coef   <- do.call(rbind,lapply(R, function(x){x$coefficients[1:(length(x$coefficents)-1)]}))
coef   <- do.call(rbind,lapply(R, function(x){x$coefficients[1:2]}))
coef   <- do.call(rbind,lapply(Re, function(x){x$coefficients[1:2]}))
trim   <- length(setdiff(all.vars(formula(R[[1]])),names(dt_data)))
trim
trim   <- vapply(R, function(r){length(setdiff(all.vars(formula(r)),names(dt_data)))}
)
trim   <- lapply(R, function(r){length(setdiff(all.vars(formula(r)),names(dt_data)))})
trim
trim   <- unlist(lapply(R, function(r){length(setdiff(all.vars(formula(r)),names(dt_data)))}))
trim
1:1
formula(r)
formula(R]]1)
formula(R[[1]])
trim_index <- unlist(lapply(R, function(r){length(1 + all.vars(formula(r)))-length(setdiff(all.vars(formula(r)),names(dt_data)))}))
trim_index <- unlist(lapply(R, function(r){1 + length(all.vars(formula(r)))-length(setdiff(all.vars(formula(r)),names(dt_data)))}))
coef   <- do.call(rbind,lapply(R, function(x){x$coefficients[1:trim_index]}))
coef
names(coef)
dimnames(coef)
trim_index <- unlist(lapply(R, function(r){length(x$coefficients)-trimlength(all.vars(formula(r)))-length(setdiff(all.vars(formula(r)),names(dt_data)))}))
trim_index <- unlist(lapply(R, function(r){length(r$coefficients)-trimlength(all.vars(formula(r)))-length(setdiff(all.vars(formula(r)),names(dt_data)))}))
trim_index <- unlist(lapply(R, function(r){length(r$coefficients)-length(all.vars(formula(r)))-length(setdiff(all.vars(formula(r)),names(dt_data)))}))
trim_index
trim_index <- unlist(lapply(R, function(r){length(r$coefficients)-length(setdiff(all.vars(formula(r)),names(dt_data)))}))
trim_index
coef   <- do.call(rbind,lapply(R, function(x){x$coefficients[1:trim_index]}))
Rsq    <- do.call(rbind,lapply(S, function(x){x$r.squared}))
pval   <- do.call(rbind,lapply(S, function(x){(x$coef)[1:trim_index,4]}))
pval
dim(pval)
dimnames(pval)
returnResults <- function(R){
S <- lapply(R, summary)
trim_index <- unlist(lapply(R, function(r){length(r$coefficients)-length(setdiff(all.vars(formula(r)),names(dt_data)))}))
coef   <- do.call(rbind,lapply(R, function(x){x$coefficients[1:trim_index]}))
Rsq    <- do.call(rbind,lapply(S, function(x){x$r.squared}))
pval   <- do.call(rbind,lapply(S, function(x){(x$coef)[1:trim_index,4]}))
dimnames(Rsq)[[2]] <- "R2"
dimnames(pval)[[2]] <- paste0("p.", dimnames(pval)[[2]])
results <- as.data.frame(do.call(cbind, list(coef, pval, Rsq)))
results$plant_code <- as.integer(dimnames(results)[[1]])
results <- data.table(results)
setkey(results,plant_code)
results <- merge(results, dt_unit_info[,list(plant_code, HUC2, nStorage, drain)], by=c("plant_code"))
setkey(results,HUC2)
return(results)
}
res1 <- returnResults(R)
returnResults <- function(R){
S <- lapply(R, summary)
trim_index <- unlist(lapply(R, function(r){length(r$coefficients)-length(setdiff(all.vars(formula(r)),names(dt_data)))}))
coef   <- do.call(rbind,lapply(R, function(x){x$coefficients[1:trim_index]}))
Rsq    <- do.call(rbind,lapply(S, function(x){x$r.squared}))
pval   <- do.call(rbind,lapply(S, function(x){(x$coef)[1:trim_index,4]}))
dimnames(Rsq)[[2]] <- "R2"
dimnames(pval)[[2]] <- paste0("p.", dimnames(pval)[[2]])
results <- as.data.frame(do.call(cbind, list(coef, pval, Rsq)))
results$plant_code <- as.integer(dimnames(results)[[1]])
results <- data.table(results)
setkey(results,plant_code)
results <- merge(results, dt_unit_info[,list(plant_code, HUC2, nStorage, drain)], by=c("plant_code"))
setkey(results,HUC2)
return(results)
}
res1 <- returnResults(R)
returnResults <- function(R){
S <- lapply(R, summary)
trim_index <- unlist(lapply(R, function(r){length(r$coefficients)-length(setdiff(all.vars(formula(r)),names(dt_data)))}))
coef   <- do.call(rbind,lapply(R, function(x){x$coefficients[1:trim_index]}))
Rsq    <- do.call(rbind,lapply(S, function(x){x$r.squared}))
pval   <- do.call(rbind,lapply(S, function(x){(x$coef)[1:trim_index,4]}))
dimnames(Rsq)[[2]] <- "R2"
dimnames(pval)[[2]] <- paste0("p.", dimnames(pval)[[2]])
results <- as.data.frame(do.call(cbind, list(coef, pval, Rsq)))
results$plant_code <- as.integer(dimnames(results)[[1]])
results <- data.table(results)
setkey(results,plant_code)
results <- merge(results, dt_unit_info[,list(plant_code, HUC2, nStorage, drain)], by=c("plant_code"))
setkey(results,HUC2)
return(results)
}
res1 <- returnResults(R)
head(res1)
res2 <- returnResults(Re)
res2
Re[[1]]
summary(Re[[1]])
plot(density(res2[.(c(2)),list(drain,R2)]))
res2
res2[.(c(2))[]
res2[.(c(2))]
res2[.(c(2)), list(drain, R2)]
plot(density(res2[.(c(2)),list(drain/R2)]))
plot(density(res2[.(c(2)),R2]))
plot(density(res1[.(c(2)),R2]))
plot(results[,list(log(drain/nStorage), R2, )])
plot(res2[,list(log(drain/nStorage), R2, )])
plot(results[,list(log(drain/nStorage), p.totrun <0.05)])
plot(res2[,list(log(drain/nStorage), p.totrun <0.05)])
plot(density(res2[,R2]))
plot(density(res1[,R2]))
plot(res2[,list(log(drain/nStorage), log(totrun))]) # Some pattern here... larger response
plot(density(res1[,R2]))
plot(density(res2[,R2]))
summary((res2[,R2]))
R[[1]]
Re[[1]]
plot(res2[,list(log(drain/nStorage), log(totrun))]) # Some pattern here... larger response
plot(res2[,list(log(drain), log(totrun))]) # Some pattern here... larger response
plot(res2[,list(log(nStorage), log(totrun))]) # Some pattern here... larger response
rev(1:10)
rev(sort(c("B","A","C")))
sample = data.frame(Item = c("B", "A", "C"), CatOne = c(50,30,10), CatTwo = c(30,30,40), CatThree = c(20,40,50))
sample.lik = likert(summary=sample)
require(likert)
sample = data.frame(Item = c("B", "A", "C"), CatOne = c(50,30,10), CatTwo = c(30,30,40), CatThree = c(20,40,50))
sample.lik = likert(summary=sample)
likert.bar.plot(sample.lik) + scale_x_discrete(limits=rev(sort(sample$Item)))
likert.bar.plot(sample.lik) + scale_x_discrete(limits=rev(sample$Item))
install.packages("C:/Users/mhdan_000/Dropbox/code/r/packages/gEcon_0.9.1.zip", repos = NULL)
library(gecon)
library(gEcon)
library("gEcon")
require(gEcon)
install.packages("nleqslv")
require(gEcon)
?gEcon
??gEcon
P = matrix(ncol = 5,
c(0,0,0.5,0,0.5,
0,0,1,0,0,
0.25, 0.25, 0, 0.25, 0.25,
0,0,0.5,0,0.5,
0,0,0,0,1), byrow = T)
P
start = c(0,1,0,0,0)
start = t(c(0,1,0,0,0))
x = start * P
start
x = start %*% P
x
P ^2
sapply(1:100, function(n){
1 - (x %*% P^n)[5] # Mouse alive
})
x
sapply(1:100, function(n){
1 - (start %*% P^n)[5] # Mouse alive
})
start %*% P
start %*% P^ 3
start %*% P %*% P
pow <- function(M, n){
R = 1
for(i in 1:n){
R = R %*% M
}
return(R)
}
sapply(1:100, function(n){
1 - (start %*% pow(M, n))[5] # Mouse alive
})
sapply(1:100, function(n){
1 - (start %*% pow(P, n))[5] # Mouse alive
})
1 %*% P
identity(5)
I(5)
matrix(1)
matrix(5)
diag(5)
dim(P)
pow <- function(M, n){
R = diag(dim(M)[1])
for(i in 1:n){
R = R %*% M
}
return(R)
}
sapply(1:100, function(n){
1 - (start %*% pow(P, n))[5] # Mouse alive
})
alive = sapply(1:100, function(n){
1 - (start %*% pow(P, n))[5] # Mouse alive
})
bar.plot(alive)
barplot(alive)
barplot(alive[1:20])
seq(1,10, length.out = 20)
install.packages("MDPtoolbox")
require(MDPtoolbox)
MDPtoolbox::demo
MDPtoolbox::demo()
set.seed(0)
mdp_example_rand(2, 2)
mdp_example_rand(2, 2, FALSE)
mdp_example_rand(2, 2, TRUE)
mdp_example_rand(2, 2, FALSE, matrix(c(1,0,1,1),2,2))
dim(matrix(1,3,3))
v = c(3,3)
v**2
Sys.getenv("PATH")
library(data.table)
library(ggplot2)
library(RPostgreSQL)
# Create your own root
src_dir = "C:/Users/mhdan_000/Dropbox/Incubator/nyctaxi/"
raw_dir = "D:/nyc_yellow_raw"
grid_dir = "D:/nyc_yellow_grid"
###############################################################################
# Name management
###############################################################################
# To be run in the raw csv directory
setwd(raw_dir)
source(file = paste0(src_dir, "nycRenaming.R"))
###############################################################################
# Parsing Raw / Appending Time Variables
###############################################################################
# appendTimeVariables(), removeVars(), clean(), cleanAll()
source(file = paste0(src_dir, "nycParseRaw.R"))
###############################################################################
# Mapping files for the grid
###############################################################################
setwd(src_dir)
source(file = paste0(src_dir, "nycMapping.R"))
if (!require(gpclib)) install.packages("gpclib", type="source")
gpclibPermit() #
if (!require(gpclib)) install.packages("gpclib", type="source")
tracts = spTransform(readOGR("./nyct2010_15b", layer = "nyct2010"), CRS("+proj=longlat +datum=WGS84"))
tracts@data$id = as.character(as.numeric(rownames(tracts@data)) + 1)
tracts.points = fortify(tracts, region = "id")
tracts.map = inner_join(tracts.points, tracts@data, by = "id")
nyc_map = tracts.map
ex_staten_island_map = filter(tracts.map, BoroName != "Staten Island")
saveCodeMap <- function(nyc_map){
write.csv(row.names = F, file = "tract_codes.csv", x = unique(nyc_map[,c("id", "CTLabel", "BoroName", "BoroCode", "CT2010", "BoroCT2010", "CDEligibil", "NTACode", "NTAName")]))
}
roughingGrid <- function(dt, var="pickup",  nyc_map, n = 800, offset = 0.00001){
# Returns the cell number corresponding to a lat/lon
# in a roughing grid (n x n), within the extents of the nyc_map.
# Vectorized
# Construct extremes of nyc_map (for use in roughing bounds)
lat.min = min(nyc_map$lat) - offset # eliminates edge case (1,0] in roughingGrid()
lat.max = max(nyc_map$lat)
lon.min = min(nyc_map$lon) - offset # eliminates edge case (1,0] in roughingGrid()
lon.max = max(nyc_map$lon)
lat.width = (lat.max - lat.min) / n
lon.width = (lon.max - lon.min) / n
setnames(dt, paste0(var,"_latitude"), "lat")
setnames(dt, paste0(var,"_longitude"), "lon")
# For a point, returning the roughingGrid cell number
# (top to bottom, *RIGHT TO LEFT*)
dt[, grid := ((lat.max - lat) %/% lat.width) * n +
(lon.max - lon) %/% lon.width + 1]
# Clip the box
dt[lon > lon.max, grid := NA]
dt[lat > lat.max, grid := NA]
dt[lon < lon.min, grid := NA]
dt[lat < lat.min, grid := NA]
setnames(dt, c("lat", "lon", "grid"),
paste0(var, c("_latitude", "_longitude", "_grid")))
# Testing
# Check corners
#  roughingGrid(max(nyc_map$lon), max(nyc_map$lat), nyc_map, n = 20) # 1
#  roughingGrid(min(nyc_map$lon), max(nyc_map$lat), nyc_map, n = 20) # n
#  roughingGrid(min(nyc_map$lon), min(nyc_map$lat), nyc_map, n = 20) # n*n
#  roughingGrid(max(nyc_map$lon), min(nyc_map$lat), nyc_map, n = 20) # n*(n-1) + 1
# Time it: 0.6s with boundary checking, 0.35s w/o
# system.time(dt200901[,grid := roughingGrid(pickup_longitude, pickup_latitude)])
# sum(is.na(dt200901$grid)) # 247k outside the grid
}
roughingGridPolys <- function(nyc_map, n = 800, offset = 0.00001){
# Returns spatialpolygonsdataframe corresponding to the roughing grid
library(rgeos)
lat.min = min(nyc_map$lat) - offset # eliminates edge case (1,0] in roughingGrid()
lat.max = max(nyc_map$lat)
lon.min = min(nyc_map$lon) - offset # eliminates edge case (1,0] in roughingGrid()
lon.max = max(nyc_map$lon)
lat.width = (lat.max - lat.min) / n
lon.width = (lon.max - lon.min) / n
n.grids = n*n
grids = 1:n.grids
# generate origin of upper-right corners
row    = (grids - 1) %/% n
column = (grids - row * n) - 1
origins = data.table(lon = lon.max - column * lon.width, lat = lat.max - row * lat.width, id = grids)
# Generate polygon for every grid
Mxy <- function(x,y){
o = c(x,y)
matrix(c(o, o + c(0, -lat.width), o + c(-lon.width, -lat.width), o + c(-lon.width, 0), o),ncol = 2, byrow = T)
}
sp = origins[, list(rects = list(Mxy(lon, lat))), by = list(id)]
# Create SP
polys <- SpatialPolygons(mapply(function(rect, id) {
Polygons(list(Polygon(rect, hole = F)), ID=id)
}, as.list(sp$rects), as.list(sp$id)))
# Verify plotting from upper right
# plot(polys[c(1:10, 86:100)])
proj4string(polys) <- CRS("+proj=longlat +datum=WGS84")
return(polys )
}
roughingGridToTracts <- function(tracts, rgrid.polys){
# For each grid id in the roughing grid (corresponding to a rect)
# List the ids of the corresponding tracts
# For each polygon in polys, get list of tract ids
# over(polys[1], tracts, returnlist = T)
L <- list()
for(i in 1:length(polys)){
intersect = over(rgrid.polys[i], tracts, returnList = T)
L[[i]] <- as.vector(sapply(intersect, function(x) as.integer(x$id)))
}
return(L)
}
# over() with tracts is extremely slow
# sp = SpatialPoints(dt200901[clean == T][,list(pickup_longitude, pickup_latitude)], CRS("+proj=longlat +datum=WGS84"))
# sp = SpatialPoints(dt200901[clean == T][1:10,list(pickup_longitude, pickup_latitude)], CRS("+proj=longlat +datum=WGS84"))
# system.time(int <- over(x = sp, y = tracts)) # 15-18s per million
# Improve over() time by subsetting (divide and conquer, binary sortish)
# 1) Do once: Map rough grid boxes n x n to subset of census tracts.
# O(n2), n = 50 is 90s, n = 100 is 6.5 minutes, n = 200 is 28 min,
# system.time(rgridToTractMapN50 <- roughingGridToTracts(tracts, nyc_map, n = 50))
# saveRDS(rgridToTractMapN50, file="./gridToTractN50.RDS")
# system.time(rgridToTractMapN100 <- roughingGridToTracts(tracts, nyc_map, n = 100))
# saveRDS(rgridToTractMapN100, file="./gridToTractN100.RDS")
# system.time(rgridToTractMapN200 <- roughingGridToTracts(tracts, nyc_map, n = 200))
# saveRDS(rgridToTractMapN200, file="./gridToTractN200.RDS")
# polys = roughingGridPolys(nyc_map, n = 800, offset = 0.00001)
# system.time(rgridToTractMapN800 <- roughingGridToTracts(tracts, rgrid.polys = polys))
# saveRDS(rgridToTractMapN800, file="./gridToTractN800.RDS")
# rgridToTractMapN200 = readRDS("./gridToTractN200.RDS")
# rgridToTractMapN400 = readRDS("./gridToTractN400.RDS")
rgridToTractMapN800 = readRDS("./gridToTractN800.RDS")
# system.time(rgridToTractMapN400 <- roughingGridToTracts(tracts, nyc_map, n = 400))
# saveRDS(rgridToTractMapN400, file="./gridToTractN400.RDS")
quickSetTractId <- function(dt, map, var){
# Quick-sets the easy to find tract ids based on the roughing grid
# "0" is the explicit ID indicating that finer-spatial analysis is required
keys <- function(ids){
if(length(ids)==0){
tract.id = as.integer(NA)
}
if(length(ids)==1){
tract.id = ids[1]
}
if (length(ids) > 1){
# Multiple tract-ids per roughing id => need a closer look
tract.id = 0
}
return(tract.id)
}
N = length(map)
dt.key = data.table(grid = c(NA, 1:N), tract_id = c(NA, sapply(lapply(map,unlist), keys)))
setnames(dt, paste0(var, "_grid"), "grid")
setkey(dt,     grid)  # 3s
setkey(dt.key, grid)  # 0s
# Fast-merge
dt[, tract_id := dt.key[dt[,list(grid)]]$tract_id]
setnames(dt, "grid",     paste0(var, "_grid"))
setnames(dt, "tract_id", paste0(var, "_tract_id"))
return(NULL)
}
# Vectorized version of roughing, meant to be run for each grid or groups of grid
idOfTract <- function(lat, lon, grid){
ids = unique(unlist(rgridToTractMapN800[unique(grid)]))
sp = SpatialPoints(data.frame(lon, lat), CRS("+proj=longlat +datum=WGS84"))
out = over(sp, tracts[ids, ])
# print(length(ids)) # tracing
as.numeric(out$id)
}
appendTractIds <- function(dt, nyc_map, n = 800, map = rgridToTractMapN800){
# 2) Divide pickup/dropoff into rough grid boxes (0.7s, constant time)
roughingGrid(dt, var = "pickup",  nyc_map = nyc_map, n = n)
roughingGrid(dt, var = "dropoff", nyc_map = nyc_map, n = n)
# 3) Map through: pickup/dropoff -> tractid
quickSetTractId(dt, map = map, var = "dropoff") # 8s
quickSetTractId(dt, map = map, var = "pickup")  # 8s
# slow - spatial pairing of tract_ids for remaining points
# 50s - 90s
dt[ (pickup_tract_id == 0),  pickup_tract_id := idOfTract( pickup_latitude,  pickup_longitude,  pickup_grid), by =  pickup_grid %/% (n/2)]
dt[(dropoff_tract_id == 0), dropoff_tract_id := idOfTract(dropoff_latitude, dropoff_longitude, dropoff_grid), by = dropoff_grid %/% (n/2)]
print(paste0("Appended tract_id"))
}
# the over() call can be reduced to the appropriate tract subset
# sub = copy(dt200901)
# O(n): 4s n = 50, 8s n = 100, 17s & n = 200
# setTractId(sub, rgridToTractMapN800, var = "pickup")
# setTractId(sub, rgridToTractMapN800, var = "dropoff")
# sum(sub$pickup_tract_id==0, na.rm=T) # how many left, 13.5 m for 100, 12.9 m for 200
# Timing: 123s for n = 30, 130s for n = 100, 120s for n = 200
# system.time(sub[ (pickup_tract_id == 0),  pickup_tract_id := idOfTract( pickup_latitude,  pickup_longitude,  pickup_grid), by = pickup_grid])
# system.time(sub[(dropoff_tract_id == 0), dropoff_tract_id := idOfTract(dropoff_latitude, dropoff_longitude, dropoff_grid), by = dropoff_grid])
# testing
# idOfTract(dt200901[1,pickup_latitude], dt200901[1,pickup_longitude],  dt200901[1,pickup_grid])
# idOfTract(dt200901[1,dropoff_latitude], dt200901[1,dropoff_longitude],  dt200901[1,dropoff_grid])
# Sanity check for spatial mapping
plotPickupInTract <- function(dt, tracts){
samp.row = dt[!is.na(pickup_tract_id),][sample(.N, 1), ]
sp = SpatialPoints(samp.row[,list(pickup_longitude, pickup_latitude)])
plot(tracts[samp.row[, pickup_tract_id], ])
plot(sp, add = T)
}
setwd(raw_dir)
source(file = paste0(src_dir, "nycRenaming.R"))
source(file = paste0(src_dir, "nycParseRaw.R"))
setwd(src_dir)
source(file = paste0(src_dir, "nycMapping.R"))
files = list.files(raw_dir ,pattern = "\\.csv$", full.names = T)
f2015 <- files[grep("2015", files)]
f2014 <- files[grep("2014", files)]
f2013 <- files[grep("2013", files)]
f2012 <- files[grep("2012", files)]
f2011 <- files[grep("2011", files)]
f2010 <- files[grep("2010", files)]
f2009 <- files[grep("2009", files)]
###############################################################################
vars = c( "pickup_grid",   "pickup_datetime",  "pickup_latitude",  "pickup_longitude",
"dropoff_grid", "dropoff_datetime", "dropoff_latitude", "dropoff_longitude",
"passenger_count", "fare_rev_per_hour", "fare_amount", "total_amount", "trip_time", "trip_distance")
yearFromFile <- function(file){
n = nchar(file)
substr(file, n - 10, n - 7)
}
monthFromFile <- function(file){
n = nchar(file)
substr(file, n - 5, n - 4)
}
pipeline <- function(file, vars, con, tab, nyc_map){
# file = f2009[[1]] #test
year  = yearFromFile(file)
month = monthFromFile(file)
dt = fread(file)
# dt = copy(dt.bak)
rename(dt, all.names)
removeVars(dt)
appendTimeVariablesSimple(dt)
clean(dt)
roughingGrid(dt, var = "pickup", nyc_map = nyc_map, n = 100)
roughingGrid(dt, var = "dropoff", nyc_map = nyc_map, n = 100)
# Recode grid NAs as 0
dt[is.na(pickup_grid), pickup_grid := 0]
dt[is.na(dropoff_grid), dropoff_grid := 0]
dt = dt[(clean), vars, with = F]
{# Save sorted on pickup_grid
setkey(dt, pickup_grid, pickup_datetime, pickup_latitude, pickup_longitude, dropoff_grid, dropoff_datetime, dropoff_latitude, dropoff_longitude)
for(grid in unique(dt$pickup_grid)){
str.grid = sprintf("%05d", grid)
dir.name = paste0(grid_dir,"/pickup/",
str.grid,
"/")
dir.create(file.path(dir.name), showWarnings = FALSE)
file.name = paste0(str.grid, "_",
yearFromFile(file), "_",
monthFromFile(file), ".csv")
write.csv(dt[pickup_grid == grid],
file = paste0(dir.name, file.name), row.names = F)
}
}
{# Save sorted on dropoff_grid
setkey(dt, dropoff_grid, dropoff_datetime, dropoff_latitude, dropoff_longitude, pickup_grid, pickup_datetime, pickup_latitude, pickup_longitude)
for(grid in unique(dt$dropoff_grid)){
str.grid = sprintf("%05d", grid)
dir.name = paste0(grid_dir, "/dropoff/",
str.grid,
"/")
dir.create(file.path(dir.name), showWarnings = FALSE)
file.name = paste0(str.grid, "_",
yearFromFile(file), "_",
monthFromFile(file), ".csv")
write.csv(dt[dropoff_grid == grid],
file = paste0(dir.name, file.name), row.names = F)
}
}
print(paste0("Wrote ", file, " to grid_year_month.csv"))
}
# lapply(f2009, pipeline, vars = vars, con = con , tab = "nyc_yellow_test", nyc_map = nyc_map)
# lapply(f2010, pipeline, vars = vars, con = con , tab = "nyc_yellow_test", nyc_map = nyc_map)
lapply(f2011, pipeline, vars = vars, con = con , tab = "nyc_yellow_test", nyc_map = nyc_map)
#lapply(f2012, pipeline, vars = vars, con = con , tab = "nyc_yellow_test", nyc_map = nyc_map)
#lapply(f2013, pipeline, vars = vars, con = con , tab = "nyc_yellow_test", nyc_map = nyc_map)
#lapply(f2014, pipeline, vars = vars, con = con , tab = "nyc_yellow_test", nyc_map = nyc_map)
#lapply(f2015, pipeline, vars = vars, con = con , tab = "nyc_yellow_test", nyc_map = nyc_map)
lapply(f2012, pipeline, vars = vars, con = con , tab = "nyc_yellow_test", nyc_map = nyc_map)
lapply(f2015, pipeline, vars = vars, con = con , tab = "nyc_yellow_test", nyc_map = nyc_map)
