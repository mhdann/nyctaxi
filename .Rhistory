return(f)
}
truncPoints <- function(points, crossPoints){
a <- crossPoints[1,'x']
b <- crossPoints[2,'x']
index <- (points[,'x'] > a) & (points[,'x'] < b)
rbind(rbind(crossPoints[1,], points[index, ]), crossPoints[2,])
}
# End library
L <- list()
for(plant in DATA[HUC2==18,unique(plant_code)]){
R <-list()
R$plant_code <- plant
f <- as.matrix(monthly[plant_code==plant,list(percentGen, percentTotrun)])
if(any(is.na(f))){next}
points1 = seasonToCycle(f[,1])
points2 = seasonToCycle(f[,2])
crossPoints <- crossover(points1, points2)
R$crossPoints <- crossPoints
R$generation  <- points1
R$totrun      <- points2
if(dim(crossPoints)[1]==2){
# truncate points1 and points2 to the crossover points
points1_trunc <- truncPoints(points1, crossPoints)
points2_trunc <- truncPoints(points2, crossPoints)
A1 = trapz(points1_trunc$x, points1_trunc$y)
A2 = trapz(points2_trunc$x, points2_trunc$y)
R$storage <- abs(A1-A2)
} # bail if multiple points
n <- length(L)+1
L[[n]] <- R
names(L)[n] <- plant
}
L[[40]]
L[[40]]$crossPoints
plot(L[[40]]$totrun)
lines(L[[40]]$totrun)
lines(L[[40]]$generation)
abline(v=L[[40]][,"x"])
abline(v=L[[40]]$crossPoints[,"x"])
plotIt <- function(R){
plot(R$totrun)
lines(R$totrun)
lines(R$generation)
abline(v=R$crossPoints[,"x"])
}
plotIt(L[[40]])
plotIt(L[[39]])
abline(v=R$crossPoints[,"x"], lty=2)
plotIt <- function(R){
plot(R$totrun)
lines(R$totrun)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
plotIt(L[[39]])
plotIt <- function(R){
plot(R$totrun)
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
plotIt(L[[39]])
plot(R$totrun, xlab="Month", ylab="Percent")
plot(R$totrun, xlab="Month", ylab="Percent", main=R$plant)
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
lapply(R)
plotIt(L[[29]])
plotIt(L[[28]])
plotIt(L[[27]])
plotIt(L[[25]])
plotIt(L[[24]])
plotIt(L[[23]])
plotIt(L[[22]])
plotIt(L[[21]])
plot(R$totrun, xlab="Month", ylab="Percent", title=R$plant)
plotIt <- function(R){
plot(R$totrun, xlab="Month", ylab="Percent", main=R$plant)
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
warnings()
21
plotIt(L[[21]])
dt_unit_info[plant_code==240]
dt_unit_info[plant_code==240, plant.dam.name]
plotIt(L[[20]])
dt_unit_info[plant_code==239, plant.dam.name]
dt_unit_info[plant_code==233, plant.dam.name]
dt_unit_info[plant_code==232, plant.dam.name]
plotIt(L[[19]])
plotIt(L[[50]])
plotIt(L[[100]])
plotIt <- function(R){
plot(R$totrun, xlab="Month", ylab="Percent", main=paste(R$plant,": ", round(R$storage)))
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
plotIt(L[[100]])
plotIt <- function(R){
plot(R$totrun, xlab="Month", ylab="Percent", main=paste(R$plant,": ", round(R$storage,3)))
lines(R$totrun, col=4)
lines(R$generation)
abline(v=R$crossPoints[,"x"], lty=2)
}
plotIt(L[[100]])
ecm.sim <- function(L1.Y, L1.X, X, beta){
# Can handle multi-dimensional X, but not Y
D1.X = X - L1.X
Y = D1.X %*% t(beta$SR) + beta$adj * (L1.Y - L1.X %*% t(beta$LR))
return(Y)
}
LR.beta       = 2
SR.beta       = 1
adj.beta      = 0.5      # Percent falloff back to trend. 1 = complete adj.
per     = 1 - adj  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
LR.Y = LR.beta*X   # Underlying LR trend
per     = 1 - adj.beta  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
LR.Y = LR.beta*X   # Underlying LR trend
shocks = c(1, rep(0,99))
#shocks = rnorm(100, sd=0.2)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ecm.sim <- function(L1.Y, L1.X, X, beta){
# Can handle multi-dimensional X, but not Y
D1.X = X - L1.X
Y = D1.X %*% t(beta$SR) + beta$adj * (L1.Y - L1.X %*% t(beta$LR))
return(Y)
}
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y)
ts.plot(Y,x)
ts.plot(Y,X)
ts.plot(Y,ts(X))
LR.beta       = 2
SR.beta       = 1
adj.beta      = -0.5      # Percent falloff back to trend. 1 = complete adj.
per     = 1 - adj.beta  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
shocks = c(1, rep(0,99))
#shocks = rnorm(100, sd=0.2)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
per     = adj.beta-1  # Persistence of shocks
ts.plot(shocks)
shocks = rnorm(100, sd=0.2)
LR.beta       = 2
SR.beta       = 1
adj.beta      = -0.5      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.2)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
shocks = rnorm(100, sd=1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
ecm.sim <- function(L1.Y, L1.X, X, beta){
# Can handle multi-dimensional X, but not Y
D1.X = X - L1.X
D.Y = D1.X %*% t(beta$SR) + beta$adj * (L1.Y - L1.X %*% t(beta$LR))
return(D.Y)
}
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -0.5      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[2]
}
ts.plot(Y,ts(X))
ts.plot(Y,ts(X), col=(c(2,1)))
ts.plot(LR.y)
ts.plot(LR.Y)
ts.plot(Y,ts(X), col=(c(2,1)))
ts.plot(shocks)
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
shocks = rnorm(100, sd=0.1)
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -1      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -0.1      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -0.6      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12) + rnorm()
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.5)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 0
adj.beta      = -0.2      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
shocks = rnorm(100, sd=0.1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 2
SR.beta       = 2
adj.beta      = -0.2      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
LR.beta       = 0
SR.beta       = 2
adj.beta      = -0.2      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
LR.beta       = 0
SR.beta       = 2
adj.beta      = 0      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,100)*(2*pi)/12)
#shocks = c(1, rep(0,99))
shocks = rnorm(100, sd=0.1)
Y = rep(as.numeric(NA),100)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
N             = 100
LR.beta       = 0
SR.beta       = 2
adj.beta      = 0      # Percent falloff back to trend. 1 = complete adj.
per     = adj.beta - 1  # Persistence of shocks
X = sin(seq(1,N)*(2*pi)/12)
#shocks = c(1, rep(0,99))
shocks = rnorm(N, sd=0.1)
Y = rep(as.numeric(NA),N)
Y[1] = LR.Y[1] + shocks[1]
# Update values based on shocks
for(i in 2:length(Y)){
Y[i] = Y[i-1] + ecm.sim(Y[i-1],X[i-1],X[i],beta=list(adj=adj.beta, LR=LR.beta,SR=SR.beta)) + shocks[i]
}
ts.plot(Y,ts(X), col=(c(2,1)))
".RData"
ls()
pwd()
q()
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./test.db")
library(RSQLite)
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./test.db")
data(USArrests)
# Write data "USArrests" in table "USArrests" in database "test.db"
dbWriteTable(con, "arrests", USArrests)
dbGetQuery(con, "SELECT * FROM arrests WHERE Murder > 10")
library(RSQLite)
setwd("D:/data/taxi")
library(RSQLite)
drv <- dbDriver("SQLite")
park = dbReadTable(con, "park")
setwd("D:/data/taxi/nyctaxi")
library(RSQLite)
# Set up database connection
drv <- dbDriver("SQLite")
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./taxiDB/test2.db")
con <- dbConnect(drv, dbname = "./nyc_DB/test2.db")
park = dbReadTable(con, "park")
class(park)
park = data.table(park)
library(data.table)
park = data.table(dbReadTable(con, "park"))
class(park)
park
dbDisconnect(con)
rm(park)
gc()
rm(t2015)
park
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./nyc_DB/test2.db")
# dbWriteTable(con, "park", park, overwrite = T)
park = data.table(dbReadTable(con, "park"))
# park = as.data.table(dbGetQuery(con, "SELECT * FROM park"))
dbDisconnect(con)
con <- dbConnect(drv, dbname = "./nyc_DB/gridded.db")
# dbWriteTable(con, "park", park, overwrite = T)
park = data.table(dbReadTable(con, "park"))
# park = as.data.table(dbGetQuery(con, "SELECT * FROM park"))
dbDisconnect(con)
gc()
park
library(RSQLite)
library(data.table)
setwd("D:/data/taxi/nyctaxi")
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./nyc_DB/gridded.db")
dbDisconnect(con)
names(park)
park.binned = park[clean == T, .N, by = list(pickup_cell, Month, Weekday, pickup_day, pickup_hour)]
park.binned
lapply(park, class)
park.binned = park[clean == T, list(rides = .N,
passenger_count = sum(passenger_count, na.rm = T),
fare_amount = mean(fare_amount, na.rm = T),
fare_rev_per_hour = mean(fare_rev_per_hour, na.rm = T),
trip_distance = mean(trip_distance, na.rm = T)),
by = list(pickup_cell, Month, Weekday, pickup_day, pickup_hour)]
park.binned
con <- dbConnect(drv, dbname = "./nyc_DB/gridded.db")
dbWriteTable(con, "park_binned", park.binned)
dbDisconnect(con)
library(RSQLite)
drv <- dbDriver("SQLite")
con <- dbConnect(drv, dbname = "./nyc_DB/gridded.db")
park.binned2 = data.table(dbReadTable(con, "park_binned")
)
dim(park.binned2)
dim(park.binned)
rm(park.binned)
dbDisconnect(con)
wunder = fread("./wunder/wunder.csv")
names(wunder)
wunder = fread("./wunder/wunder.csv")[year == 2015,]
names(wunder)
wunder
park.binned
park.binned2
park.binned = park.binned2
rm(park.binned)
park.binned = park.binned2
rm(park.binned2)
gc()
setnames(park.binned, Month, month)
setnames(park.binned, "Month", "month")
names(park.binned)
setkey(park.binned, month, pickup_day, pickup_hour)
setkey(wunder     , month,        day,        hour)
wunder[park.binned]
park.binned[wunder]
setnames(wunder, c("pickup_day", "pickup_hour"), c("day", "hour"))
setnames(wunder, c("day", "hour"), c("pickup_day", "pickup_hour"))
setkey(park.binned, month, pickup_day, pickup_hour)
setkey(wunder     , month, pickup_day, pickup_hour)
wunder[park.binned]
park.binned[wunder]
wunder = fread("./wunder/wunder.csv")[year == 2015 & month %in% 1:6,]
setnames(wunder, c("day", "hour"), c("pickup_day", "pickup_hour"))
setkey(park.binned, month, pickup_day, pickup_hour)
setkey(wunder     , month, pickup_day, pickup_hour)
wunder
wunder[park.binned]
park.binned[wunder]
wunder = fread("./wunder/wunder.csv")[year == 2015 & month %in% 1:6, list(year, month, day, hour, temperature, precipitation, windspeed)]
setnames(wunder, c("day", "hour"), c("pickup_day", "pickup_hour"))
wunder
setkey(park.binned, month, pickup_day, pickup_hour)
setkey(wunder     , month, pickup_day, pickup_hour)
wunder
wunder[park.binned]
expand.grid(month = 1:6, year = 2014)
wunder[,unique(month, pickup_day)]
wunder[,unique(c(month, pickup_day))]
unique(list(c(1,1), c(2,1)))
wunder[,unique(list(c(month, pickup_day)))]
wunder[,c(month, pickup_day)]
wunder[,list(c(month, pickup_day))]
wunder[,list(list(c(month, pickup_day)))]
wunder[,list(list((month, pickup_day)))]
wunder[,list(list(month, pickup_day))]
unique(wunder[,list(month, pickup_day)])
unique(wunder[,list(month, pickup_day, hour)])
unique(wunder[,list(month, pickup_day, pickup_hour)])
expand.grid(pickup_cell = 1:400, unique(wunder[,list(month, pickup_day, pickup_hour)])]
expand.grid(pickup_cell = 1:400, unique(wunder[,list(month, pickup_day, pickup_hour)]))
expand.grid(pickup_cell = 1:400, as.data.frame(unique(wunder[,list(month, pickup_day, pickup_hour)])))
unique(wunder[,list(month, pickup_day, pickup_hour)])
out = lapply(1:400, function(x){dt = copy(wunder); dt[, pickup_cell:=x]; return(dt)})
out
all.wunder = rbindlist(out)
setkey(park.binned, pickup_cell, month, pickup_day, pickup_hour)
setkey(wunder     , pickup_cell, month, pickup_day, pickup_hour)
setkey(all.wunder , pickup_cell, month, pickup_day, pickup_hour)
all.wunder[park.binned]
data = all.wunder[park.binned]
data[rides ==0]
data
data[is.na(rides)]
data[, l_rides:= log(rides)]
data[, precip := 0]
data[, precip := 0]
data[!is.na(precipitation) & precipitation > 0, precip := 1]
data[, l_rides:= log(rides)]
fm = lm(data, formula = "l_rides ~ factor(month) + factor(Weekday) + temperature + factor(precip) + factor(pickup_cell)")
fm
summary(fm)
exp(1.6)
exp(1.6e-2)
data
data[precip==1, list(precip, precipitation)]
saveRDS(fm, "reg1_rides.rds")
object.size(fm)
summary(fm)
object.size(summary(fm))
saveRDS(summary(fm), "reg1_rides.rds")
